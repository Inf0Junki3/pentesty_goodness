#!/usr/bin/python2
import argparse
import sctp
import socket
import ssl
import sys
import threading

CONNECTIONS         = 5
sctp_socket         = sctp.sctpsocket_tcp
accept_connections  = True

# DISCLAIMER: this code is largely copied and refactored from gallopsled's excellent pwntools. 
# Hat tip to them.
def interactive_read(sock, bye_bye):
    while not bye_bye.isSet():
        # receive data and write it to the screen:
        try:
            cur_data = sock.recv(1024)
            if cur_data:
                sys.stdout.write(cur_data)
                sys.stdout.flush()
        except EOFError:
            print "EOF - terminating"
            break

def interactive_write(sock, bye_bye):
    try:
        while not bye_bye.isSet():
            data = sys.stdin.read(1)
            if data:
                try:
                    sock.send(data)
                except (EOFError, socket.error) as e:
                    print "EOF - terminating"
                    bye_bye.set()
            else:
                bye_bye.set()
    except KeyboardInterrupt:
        print "CTRL + C pressed."
        bye_bye.set()

def process_connection(connection, disable_encryption = False):
    # connect connection's stdin to my stdin, connection's stdout to my stdout.
    print "Got connection, setting up interactive terminal."
    if disable_encryption:
        sock = connection.sock()
    else:
        sock        = ssl.wrap_socket(connection.sock(),
                                      server_side   = True,
                                      certfile      = "server.crt",
                                      keyfile       = "server.key",
                                      ssl_version   = ssl.PROTOCOL_TLSv1)
    bye_bye     = threading.Event()

    read_thread = threading.Thread(target = interactive_read, args = (sock, bye_bye))
    read_thread.setDaemon(True)
    read_thread.start()

    interactive_write(sock, bye_bye)

    while read_thread.is_alive():
        read_thread.join(timeout = 0.1)
        
# END DISCLAIMER

def listen_for_connections(sock_addresses, disable_encryption = False):
    print "Listening for connections, hit CTRL + C to exit."
    sock = sctp_socket(family = socket.AF_INET)
    sock.bindx(sock_addresses)
    sock.listen(CONNECTIONS)
    while (accept_connections == True):
        conn = sock.accept()
        process_connection(conn[0], disable_encryption)
        print "Listening for connections, hit CTRL + C to exit."

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description = ("SCTP covert channel server. "
                                     "Don't be a jerk; use this only for professional pentesting."))
    parser.add_argument("--host", 
                        help        = "The IP address you want to listen on.", 
                        required    = True)
    parser.add_argument("--port", 
                        help        = "The port you want to listen on.", 
                        required    = True, 
                        type        = int)
    parser.add_argument("--no-encryption",
                        help        = "FOR DEBUGGING ONLY. Disables encryption",
                        action      = "store_true")
    args = parser.parse_args()
    listen_for_connections([(args.host, args.port)], args.no_encryption)
