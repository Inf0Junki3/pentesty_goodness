#!/usr/bin/python2

# Runs a preliminary analysis on a binary (such as a native mobile app library); identifies calls
# to dangerous functions, checks in what functions they are called.

# *Prerequisites*: python, pyaml, r2pipe, radare2.

# NOTES: This has limited use on a really big binary; my recommendation is to use a restricted list
# of dangerous functions in that case.

# TODO: Would be nice to identify paths to the vulnerable functions, kind of like the proximity
# functionality of ida pro.

import                argparse
from termcolor import colored
import                r2pipe
import                yaml

parser = argparse.ArgumentParser("Runs preliminary analysis on a binary")
parser.add_argument("target", help = "[Required] The target binary.")
parser.add_argument("--dangerous_fcn_yml", 
                    help     = "[Optional] Specify a yml file. Default: dangerous_functions.yml",
                    default  = "dangerous_functions.yml",
                    required = False)
parser.add_argument("--category",
                    help     ="[Optional] specify a given category of dangerous functions.",
                    default  = None,
                    required = False)
parser.add_argument("--verbose",
                    help = "[Optional] Include calls to the vulnerable function.",
                    action = "store_true",
                    default = False,
                    required = False)

def parse_dangerous_functions(yaml_file):
    with open(yaml_file, "r") as dangerous_functions_file:
        dangerous_functions_content = yaml.load(dangerous_functions_file.read())
    return dangerous_functions_content

def parse_symbol_info(field, dest_dict):
    if len(field) > 0:
        key_val = field.split("=")
        if key_val[0] == "name":
            key_val[1] = "sym." + key_val[1]
        dest_dict.update({key_val[0].strip() : key_val[1].strip()})

def parse_calls(raw, verbose):
    results = []
    for cur_line in raw.split("\n"):
        fields = cur_line.split(" ")
        if len(fields) > 1:
            if fields[-1] == "function" and verbose:
                print colored("DEBUG: {}".format(" ".join(fields)), "yellow")
            results.append(dict(addr = fields[1], name = fields[-1]))
    return results

def get_call_tree(r2, function_name_or_addr, verbose, recursion_level = 1):
    refs = parse_calls(r2.cmd("axt @ {}".format(function_name_or_addr)), verbose)
    if recursion_level > 1:
        for ref in refs:
            if ref["name"] == "function":
                reference = ref["addr"]
            else:
                reference = ref["name"]
            ref.update({"refs": get_call_tree(r2, reference)})
    return refs

def find_dangerous_function_calls(target, category_filter, dangerous_functions, verbose):
    r2 = r2pipe.open(target)
    # Set up colors
    r2.cmd("e scr.color = true")
    # Run analysis
    r2.cmd("aaaa")
    symbols_to_examine = []
    for cat_label, category in dangerous_functions.iteritems():
        if category_filter is not None and category_filter.strip() != cat_label:
            if verbose:
                print "Skipping {}".format(cat_label)
            continue
        for fct in category:
            fct_info_raw = r2.cmd("is~{}".format(fct))
            fct_info = {}
            map(lambda x: parse_symbol_info(x, fct_info), fct_info_raw.split(" "))
            if len(fct_info) > 0:
                symbols_to_examine.append(fct_info)
    for symbol in symbols_to_examine:
        symbol_name = symbol["name"]
        calls = parse_calls(r2.cmd("axt @ {}".format(symbol_name)), verbose)
        if len(calls) > 0:
            print colored("Calls to {}".format(symbol_name), "red")
            for call in calls:
                callers         = get_call_tree(r2, call["name"], verbose)
                callers_names   = [x["name"] for x in callers]
                if len(callers_names) == 0:
                    callers_names = ["(no ref)"]
                print "{1}: {0}".format(call["addr"], 
                                        call["name"])
                if verbose: 
                   print colored("\tCalled by: ", "green")
                   print colored("\n\t".join(callers_names), "green")

if __name__ == "__main__":
    args = parser.parse_args()
    find_dangerous_function_calls(args.target, 
                                  args.category,
                                  parse_dangerous_functions(args.dangerous_fcn_yml),
                                  args.verbose)
