#!/usr/bin/python2

# Runs a preliminary analysis on a binary (such as a native mobile app library); identifies calls
# to dangerous functions, checks in what functions they are called.

# *Prerequisites*: python, pyaml, radare2 with the bindings. Follow the (straightforward) functions
# at https://github.com/radare/radare2-bindings for the radare2 bindings. Approx setup time is 20m.

# NOTES: This has limited use on a really big binary; my recommendation is to use a restricted list
# of dangerous functions in that case.

# TODO: Would be nice to identify paths to the vulnerable functions, kind of like the proximity
# functionality of ida pro.
import                argparse
from termcolor import colored
import                r2pipe
import                yaml

parser = argparse.ArgumentParser("Runs preliminary analysis on a binary")
parser.add_argument("target", help = "[Required] The target binary.")
parser.add_argument("--dangerous_fcn_yml", 
                    help     = "[Optional] Specify a yml file. Default: dangerous_functions.yml",
                    default  = "dangerous_functions.yml",
                    required = False)
parser.add_argument("--category",
                    help     ="[Optional] specify a given category of dangerous functions.",
                    default  = None,
                    required = False)
parser.add_argument("--verbose",
                    help = "[Optional] Include calls to the vulnerable function.",
                    action = "store_true",
                    default = False,
                    required = False)

def parse_dangerous_functions(yaml_file):
    with open(yaml_file, "r") as dangerous_functions_file:
        dangerous_functions_content = yaml.load(dangerous_functions_file.read())
    return dangerous_functions_content

def find_dangerous_function_calls(target, category_filter, dangerous_functions, verbose):
    r2 = r2pipe.open(target)
    r2.cmd("aaaa")
    functions = []
    symbols = r2.cmd("is")
    for symbol in symbols.split("\n"):
        if "FUNC" in symbol:
            function_name = symbol.split(" ")[-1]
            function_addr = symbol.split(" ")[2]
            functions.append([function_name, function_addr])

    symbols_to_examine = []
    for cat_label, category in dangerous_functions.items():
        if category_filter is not None and category_filter.strip() != cat_label:
            if verbose:
                print("Skipping {}".format(cat_label))
            continue
        for fct in category:
            for bin_func in functions:
                if fct in bin_func[0]:
                    symbols_to_examine.append([bin_func, cat_label])
    for symbol in symbols_to_examine:
        print(colored(symbol[1], "red"))
        print(colored(r2.cmd("axt @ {}".format(symbol[0][1])), "blue"))
        #xrefs = r2.anal.xrefs_get(symbol.addr)
        #if len(xrefs) > 0:
        #    print(colored("{}:".format(symbol.name), "red"))

        #for xref in xrefs:
        #    base_addr = r2.bin.get_object().baddr
        #    print("- {}".format(hex(base_addr + xref.addr)))

if __name__ == "__main__":
    args = parser.parse_args()
    find_dangerous_function_calls(args.target, 
                                  args.category,
                                  parse_dangerous_functions(args.dangerous_fcn_yml),
                                  args.verbose)
