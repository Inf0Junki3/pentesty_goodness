#!/usr/bin/python2

# Runs a preliminary analysis on a binary (such as a native mobile app library); identifies calls
# to dangerous functions, checks in what functions they are called.

# *Prerequisites*: python, pyaml, radare2 with the bindings. Follow the (straightforward) functions
# at https://github.com/radare/radare2-bindings for the radare2 bindings. Approx setup time is 20m.

# NOTES: This has limited use on a really big binary; my recommendation is to use a restricted list
# of dangerous functions in that case.

# TODO: Would be nice to identify paths to the vulnerable functions, kind of like the proximity
# functionality of ida pro.

import                argparse
from termcolor import colored
from                  r2.r_core import *
import                yaml

parser = argparse.ArgumentParser("Runs preliminary analysis on a binary")
parser.add_argument("target", help = "[Required] The target binary.")
parser.add_argument("--dangerous_fcn_yml", 
                    help     = "[Optional] Specify a yml file. Default: dangerous_functions.yml",
                    default  = "dangerous_functions.yml",
                    required = False)
parser.add_argument("--category",
                    help     ="[Optional] specify a given category of dangerous functions.",
                    default  = None,
                    required = False)
parser.add_argument("--verbose",
                    help = "[Optional] Include calls to the vulnerable function.",
                    action = "store_true",
                    default = False,
                    required = False)

def parse_dangerous_functions(yaml_file):
    with open(yaml_file, "r") as dangerous_functions_file:
        dangerous_functions_content = yaml.load(dangerous_functions_file.read())
    return dangerous_functions_content

def find_dangerous_function_calls(target, category_filter, dangerous_functions, verbose):
    r2 = RCore()
    r2.file_open(target, 0, 0)
    r2.bin_load("", 0)

    r2.anal_all()
    functions = r2.anal.get_fcns()
    
    symbols_to_examine = []
    for cat_label, category in dangerous_functions.iteritems():
        if category_filter is not None and category_filter.strip() != cat_label:
            if verbose:
                print "Skipping {}".format(cat_label)
            continue
        for fct in category:
            for bin_func in functions:
                if fct in bin_func.name:
                    symbols_to_examine.append(bin_func)
    for symbol in symbols_to_examine:
        xrefs = r2.anal.xrefs_get(symbol.addr)
        if len(xrefs) > 0:
            print colored("{}:".format(symbol.name), "red")
        for xref in xrefs:
            #TODO: get vaddr
            base_addr = 0x08048000
            print "- {}".format(hex(base_addr + xref.addr))

if __name__ == "__main__":
    args = parser.parse_args()
    find_dangerous_function_calls(args.target, 
                                  args.category,
                                  parse_dangerous_functions(args.dangerous_fcn_yml),
                                  args.verbose)
